/*
WHATODO:

// - check the quotes if % 2 == 0
// - echo "a" b"c"
// - echo 123"hallo$"456
// - echo 123"hallo"$456
// - echo 123"hallo"$a56
// - gather args
// - remove the quotes from the nodes
// - aadad$ada type USD
// - exit_status
// - change DQUOTES_USD to USD
// - $?
- $" -> skip
 - $\0 -> print nothing
- echo 123$USER----$
- errors

// - echo hallo$"USER"
// - echo abc"hallo$USER***$USER$2$"
// - echo abc"hallo$USER ***$USER$2$"


// - !!!!! REMOVE WORD COUNT
- CHECK ARGS TYPE
- command inside "", i.e "ls"
- check other tests
- echo"
// - dquotes func
// - squotes func
...
// - redirecthelper function check
// - whitespaces function check \r\b\t\n ' '
// - ft_isspace
// - new tokenizer function
// - echo "$TEST=lol$USER'$USER'"
// - echo 'an$ddd"sd"as' -> 11
*/
// char *s = "echo abc\"hallo$USER***$USER$2$\"";



/*
echo 'file1'abc'$USD'"file2'$USER'"
echo ""

"$" => expand  => type: USD => remove quotes
'$' => no expand
"'$'" => expand  => type: USD => remove quotes
'"$"' => no expand => type: ARGS => remove quotes
''"" => no expand
""'' => no expand
''"$" => expand
'$'"" => no expand
''""$ => expand
''""'$' => no expand

FIX :
"ls" < "infile" | "cat" > "outfile"

0. loop over ARGS types, DONT loop over COMMAND or INFILE or OUTFILE, cuz it could enclosed by "", i.e: "ls" or "footer"
1. loop by character
2. if $ | if " | if '
3. set state to 1 if it finds one of the chars above
4. go till you find its pairs, then set the state back to 0
5. then check what state that last till the end and return its type either USD or just ARGS
*/


/*
echo abc"'anas'"zsh lopez
echo avc"ezsh">outfile

*/

/*
while ()
{
	ignore the whitspaces
	function for | < > if not found
}

checks :

at the start:
|
<
>
"
'
cat \"abc\" < here|
ls||
Minee: syntax error
🤙 ||
🤙 |||
🤙 ||||
🤙 |ls
|||

 kkk <
Segmentation fault: 11

j<
'echo "||"'
*/

/*
echo gaz > file station
echo "123\"456"
echo 123"hallo$"456 => expandit urself
echo hallo$'USER' => expandit urself
echo $"USERhallo"

Quotes Error! dont quit the shell


ls | | ls
ls | << | ls 
ls | > < | ls 
ls < | ls | > < | ls > f


echo "abc\"zsh "

>< ls

*/


/*
1. tokenizer:  split the input into tokens
2.0 scanner: Token Recognition : scans the tokens to identify the tokens types either => PIPE, REDIRECTION, COMMAND, TEXT, ...
	=> this step called pattern matching
2.0.1 checker: a checker to check for valid arguments
2.1 parser: read the tokens then put into a linked list -> data + next pointer
	Parsing algorithms often rely on pattern matching to transform strings into syntax trees.
3. executor -> execute the cmds


d
WHAT TO DO => [

		BUILTINSCMDS =>
		[
			"cd" => "gestion du ~ | "
			""
		]

		cmd
		text
		""
		''
		redirecthelper
		heredoc
		pipes
		$? - exit status

		Tree =>
		[
			command : < infile cat | cat > outfile
			give priority for [0. create files 1.redirection 2.pipe ..... ]

			root node: <
			child node 0 : infile
			child node 1 : cmd

			root node: >
			child node 0 : outfile
			child node 1 : cmd
		]

]



tests :

	ls > file1 | << stop cat
	redirection “>” without command ex: [> file] , should create the file

	" "
	''
	echo $
*/

/*
redirection has priority over pipe

cmd < infile | cmd > outfile
cmd < infile > outfile
< infile cmd | cmd > outfile
cmd | cmd > outfile < infile
cat | cat < infile > outfile


*/


/*
	tokenizer
1. loop input
2. spliti b < or > or |
	scanner
1. scan the tokens
2. add them to the list, if they are cmds, set there type to COMMAND, a pipe to PIPE, ...




FINAL CONCLUSION:




*/

/*

what to handle :

exit_status variable should be global
$?
$ENVV



/*
echo abc"'zs h'"
echo "'''''''a"vc"'a"bc'lopez
echo "'''''''a"vc"'a"bc'lopez'
echo ''""'$'
echo "'''''''avc"'
echo "'''''''avc"''
"'''''''avc"''
"'''''''avc"'abc'

echo abc'zsh
echo abc'zs"h'

echo "abc"'"zsh"


/**
 handle hardcoded arrays
 check more errors
 handle leaks
//  handle realloc function
//  handle norm (header file)
//  handle exit quotes in check function
//  ignore whitespaces in check < > |


// fzdsz|dcxz|sdaf"|""||||" sdafasdf   => realloc
// fzdsz|dcxz|sdaf"|""||||" sdafasdf
// fzdsz|dcxz|sdaf"|""||||" sdafasdf5 er fefef
// fzdsz|dcxz|sdaf'"fxg|'"xfd"   => realloc
// dfgsgd || fsgs

< whitespace
< a
sdgf < | sd
sdf > a > d
dsfd > a > d <f < t > l > y < s

first check
	pipe

second check
	content = <
	content = < && next == NULL => < space or < or < |
	

*/
*/

*/
